/*
 *  XmlSettings.h
 *  XmlSettings
 *
 *  Created by Andrea Cuius on 26/11/2011.
 *  Nocte Studio Copyright 2011 . All rights reserved.
 *	www.nocte.co.uk
 *
 */

#pragma once

#include "cinder/Xml.h"
#include "cinder/Utilities.h"
#include "cinder/params/Params.h"

/*
 <?xml version="1.0" encoding="utf-8"?>
 <settings>
 <float name="resolution" width="1706" height="960" />
 <bool name="runDebugMode" value="1" />
 </settings>
 */

namespace cinder { namespace settings { 
	
	static const std::string typeString[10] = { 
		"int", 
		"float", 
		"double", 
		"bool", 
		"Vec2f", 
		"Vec3f", 
		"Color", 
		"ColorA", 
		"Font", 
		"string" 
	};

	class Param {

		friend class XmlSettings;

	public:

		enum ParamType {
			PARAM_INT,
			PARAM_FLOAT,
			PARAM_DOUBLE,
			PARAM_BOOL,
			PARAM_VEC2F,
			PARAM_VEC3F,
			PARAM_COLOR,
			PARAM_COLORA,
			PARAM_FONT,
			PARAM_STRING
		};
		
		Param( const std::string &name, void *param, ParamType paramType, const std::string &category = "default", bool show = false, const std::string &option = "" ) :
				mName(name), 
				mParam(param), 
				mType(paramType), 
				mShow(show), 
				mOption(option),
				mCategory(category)
		{
		};

		template <typename T>
		T getValue() { return *static_cast<T*>(mParam); };

		template <typename T> 
		void setValue(T val) { *static_cast<T*>(mParam) = val; };

		std::string getName() { return mName; };

		std::string getType() { return typeString[mType]; };

		std::string getCategory() { return mCategory; };
		
		std::string getAsString() 
		{ 
			if ( mType == PARAM_INT )
				return ci::toString(*static_cast<int*>(mParam));
			else if ( mType == PARAM_FLOAT )
				return ci::toString(*static_cast<float*>(mParam));
			else if ( mType == PARAM_DOUBLE )
				return ci::toString(*static_cast<double*>(mParam));
			else if ( mType == PARAM_BOOL )
				return ci::toString(*static_cast<bool*>(mParam));
			else if ( mType == PARAM_VEC3F )
				return ci::toString(*static_cast<ci::Vec3f*>(mParam));
			else if ( mType == PARAM_COLOR )
				return ci::toString(*static_cast<ci::Color*>(mParam));
			else if ( mType == PARAM_COLORA )
				return ci::toString(*static_cast<ci::ColorA*>(mParam));
			else if ( mType == PARAM_STRING )
				return *static_cast<std::string*>(mParam);
		};

		void addXmlNode( ci::XmlTree &root )
		{
 			ci::XmlTree *category;
 			bool categoryExists = root.hasChild( mCategory );
			
			if ( categoryExists )
				category = &root.getChild( mCategory ); 
			else
				category = new ci::XmlTree( mCategory, "" );

			ci::XmlTree node( mName , "" );
			node.setAttribute( "type", getType() );
			
			if ( mType == PARAM_INT )
				node.setAttribute( "value", *static_cast<int*>(mParam) );
			else if ( mType == PARAM_FLOAT )
				node.setAttribute( "value", *static_cast<float*>(mParam) );
			else if ( mType == PARAM_DOUBLE )
				node.setAttribute( "value", *static_cast<double*>(mParam) );
			else if ( mType == PARAM_BOOL )
				node.setAttribute( "value", *static_cast<bool*>(mParam) );
			else if ( mType == PARAM_VEC3F )
			{
				node.setAttribute( "x", static_cast<ci::Vec3f*>(mParam)->x );
				node.setAttribute( "y", static_cast<ci::Vec3f*>(mParam)->y );
				node.setAttribute( "z", static_cast<ci::Vec3f*>(mParam)->z );
			}
			else if ( mType == PARAM_COLOR )
			{
				node.setAttribute( "r", static_cast<ci::Color*>(mParam)->r );
				node.setAttribute( "g", static_cast<ci::Color*>(mParam)->g );
				node.setAttribute( "b", static_cast<ci::Color*>(mParam)->b );
			}
			else if ( mType == PARAM_COLORA )
			{
				node.setAttribute( "r", static_cast<ci::ColorA*>(mParam)->r );
				node.setAttribute( "g", static_cast<ci::ColorA*>(mParam)->g );
				node.setAttribute( "b", static_cast<ci::ColorA*>(mParam)->b );
				node.setAttribute( "a", static_cast<ci::ColorA*>(mParam)->a );
			}
			else if ( mType == PARAM_STRING )
				node.setAttribute( "value", *static_cast<std::string*>(mParam) );

			node.setAttribute( "show", mShow );
			node.setAttribute( "option", mOption );
			node.setAttribute( "category", mCategory );

			category->push_back( node );

			if ( !categoryExists )
			{
				root.push_back( *category );
				delete category;
			}

		};

	protected:

		std::string		mName;
		void			*mParam;
		ParamType		mType;
		bool			mShow;
		std::string		mOption;
		std::string		mCategory;
	};

	class XmlSettings {

	public:

		XmlSettings() 
		{ 
			mFilename = "";
			mParamGUI = ci::params::InterfaceGl("XML SETTINGS", ci::Vec2i(280, 560));
			mParamGUI.setOptions();
		};

		void parseNode( ci::XmlTree node )
		{
			std::string type		= node.getAttributeValue<std::string>("type");
			std::string name		= node.getTag();
			std::string category	= node.getAttributeValue<std::string>("category");
			bool show				= node.getAttributeValue<bool>("show"); 
			std::string	option		= node.getAttributeValue<std::string>("option");
			bool paramFound		= false;

			for( int k=0; k < mParams.size(); k++)
			{
				if ( mParams[k]->getName() == name )
				{
					paramFound = true;

					if ( type == "int" )
						mParams[k]->setValue<int>( node.getAttributeValue<int>("value") );

					else if ( type == "float" )
						mParams[k]->setValue<float>( node.getAttributeValue<float>("value") );

					else if ( type == "double" )
						mParams[k]->setValue<double>( node.getAttributeValue<double>("value") );

					else if ( type == "Vec3f" )
						mParams[k]->setValue<ci::Vec3f>( ci::Vec3f( node.getAttributeValue<float>("x"), node.getAttributeValue<float>("y"), node.getAttributeValue<float>("z") ) );

					else if ( type == "bool" )
						mParams[k]->setValue<bool>( node.getAttributeValue<bool>("value") );

					else if ( type == "Color" )
						mParams[k]->setValue<ci::Color>( ci::Color( node.getAttributeValue<float>("r"), node.getAttributeValue<float>("g"), node.getAttributeValue<float>("b") ) );

					else if ( type == "ColorA" )
						mParams[k]->setValue<ci::ColorA>( ci::ColorA( node.getAttributeValue<float>("r"), node.getAttributeValue<float>("g"), node.getAttributeValue<float>("b"), node.getAttributeValue<float>("a") ) );

					else if ( type == "string" )
						mParams[k]->setValue<std::string>( node.getAttributeValue<std::string>("value") );
				} 
			}
			
			if ( !paramFound )
			{
				if ( type == "int" )
					addParam( name, new int( node.getAttributeValue<int>("value") ), category, show, option );

				else if ( type == "float" )
					addParam( name, new float( node.getAttributeValue<float>("value") ), category, show, option );

				else if ( type == "double" )
					addParam( name, new double( node.getAttributeValue<double>("value") ), category, show, option );

				else if ( type == "Vec3f" )
					addParam( name, new ci::Vec3f( node.getAttributeValue<float>("x"), node.getAttributeValue<float>("y"), node.getAttributeValue<float>("z") ), category, show, option );

				else if ( type == "bool" )
					addParam( name, new bool( node.getAttributeValue<bool>("value") ), category, show, option );

				else if ( type == "Color" )
					addParam( name, new ci::Color( node.getAttributeValue<float>("r"), node.getAttributeValue<float>("g"), node.getAttributeValue<float>("b") ), category, show, option );

				else if ( type == "ColorA" )
					addParam( name, new ci::ColorA( node.getAttributeValue<float>("r"), node.getAttributeValue<float>("g"), node.getAttributeValue<float>("b"), node.getAttributeValue<float>("a") ), category, show, option );

				else if ( type == "string" )
					addParam( name, new std::string(node.getAttributeValue<std::string>("value")), category, show, option );
			}
		};

		bool hasParam(std::string name) 
		{
			for( int k=0; k < mParams.size(); k++)
				if ( mParams[k]->getName() == name )
					return true;
			
			return false;
		};

		Param* getParam(std::string name) 
		{
			for( int k=0; k < mParams.size(); k++)
				if ( mParams[k]->getName() == name )
					return mParams[k];
			
			return NULL;
		};

		template <typename T>
		T	getValueByName( const std::string &name ) 
		{ 
			Param *p = getParam(name);
			
			if ( !p )
			{
				ci::app::console() << "param not found: " << name << std::endl;
				exit(-1); // throw exception instead
			}
			
			return *static_cast<T*>( p->mParam ); 
		};

		void drawDebug()
		{
			ci::TextLayout textLayout = ci::TextLayout();
			textLayout.setColor( ci::Color::white() );
			textLayout.clear( ci::Color::black() );
			textLayout.setBorder(10, 10);
			textLayout.setLeadingOffset(2);
			textLayout.setFont( ci::Font("Verdana", 13) );
			
			textLayout.addLine( "XML SETTINGS" );
			textLayout.addLine( " " );
			
			for( int k=0; k < mParams.size(); k++)
				textLayout.addLine( mParams[k]->getType() + " \t" + mParams[k]->getName() + " \t" + mParams[k]->getAsString() );
			
			ci::gl::Texture tex = ci::gl::Texture(textLayout.render(true));
			ci::gl::draw(tex);
		};

		void drawGUI()
		{
			if ( mParamsChanged )
			{
				buildXMLTree();
				buildGUI();
				mParamsChanged = false;
			}

			mParamGUI.draw();
		};

		void load( std::string filename = "" ) 
		{
			if ( filename != "" )
				mFilename = filename;
			
			if ( mFilename == "" )
			{
				ci::app::console() << "cannot load XML settings, specify filename" << std::endl;
				return;
			}
			
			try {
				mXmlAsset = ci::XmlTree( ci::loadFile(mFilename) ).getChild("/settings");
			}
			catch ( ... ) {
				ci::app::console() << "failed to load XML settings file: " << mFilename << std::endl;
				return;
			}
			
			for ( ci::XmlTree::Iter categoryIter = mXmlAsset.begin(); categoryIter != mXmlAsset.end(); ++categoryIter )
			{
				ci::XmlTree category = *categoryIter;

				for ( ci::XmlTree::Iter nodeIter = category.begin(); nodeIter != category.end(); ++nodeIter )
				{
					parseNode( *nodeIter );
				}
			}

			ci::app::console() << "XML settings loaded from: " << mFilename << std::endl;
		};

		void save( std::string filename = "" )
		{	
			if ( filename == "" )
				filename = ci::app::getAppPath().parent_path().generic_string() + "/appSettings.xml";
			
			mFilename = filename;
			
			buildXMLTree();
			
			mXmlAsset.write( ci::writeFile( mFilename ) );
			
			ci::app::console() << "XML settings saved: " << mFilename << std::endl;
			
		};

		void buildXMLTree()
		{
			mXmlAsset = ci::XmlTree("settings", "");

			for(int k=0; k < mParams.size(); k++)
				mParams[k]->addXmlNode( mXmlAsset );
		};

		void buildGUI()
		{
			for ( ci::XmlTree::Iter categoryIter = mXmlAsset.begin(); categoryIter != mXmlAsset.end(); ++categoryIter )
			{
				ci::XmlTree category = *categoryIter;
				
				mParamGUI.addText( category.getTag() );

				for ( ci::XmlTree::Iter nodeIter = category.begin(); nodeIter != category.end(); ++nodeIter )
				{
					std::string param = (*nodeIter).getTag();
					Param *p = getParam( param );
					std::string type = p->getType();
					std::string &name = p->mName;
					std::string &option = p->mOption;
					bool show = p->mShow;

					if ( type == "int" )
						mParamGUI.addParam( name, static_cast<int*>(p->mParam), option );

					else if ( type == "float" )
						mParamGUI.addParam( name, static_cast<float*>(p->mParam), option );

					else if ( type == "double" )
						mParamGUI.addParam( name, static_cast<double*>(p->mParam), option );

					else if ( type == "Vec3f" )
						mParamGUI.addParam( name, static_cast<ci::Vec3f*>(p->mParam), option );

					else if ( type == "bool" )
						mParamGUI.addParam( name, static_cast<bool*>(p->mParam), option );

					else if ( type == "Color" )
						mParamGUI.addParam( name, static_cast<ci::Color*>(p->mParam), option );

					else if ( type == "ColorA" )
						mParamGUI.addParam( name, static_cast<ci::ColorA*>(p->mParam), option );

					else if ( type == "string" )
						mParamGUI.addParam( name, static_cast<std::string*>(p->mParam), option );
				}
				mParamGUI.addSeparator();
			}
		}

		void addParam( const std::string &name, int *param, const std::string &category, bool show = false, const std::string &option = "" )
		{ addOrBind(name, param, Param::PARAM_INT, category, show, option); };

		void addParam( const std::string &name, float *param, const std::string &category, bool show = false, const std::string &option = "" )
		{ addOrBind(name, param, Param::PARAM_FLOAT, category, show, option); };

		void addParam( const std::string &name, double *param, const std::string &category, bool show = false, const std::string &option = "" )
		{ addOrBind(name, param, Param::PARAM_DOUBLE, category, show, option); };

		void addParam( const std::string &name, bool *param, const std::string &category, bool show = false, const std::string &option = "" )
		{ addOrBind(name, param, Param::PARAM_BOOL, category, show, option); };

		void addParam( const std::string &name, ci::Vec3f *param, const std::string &category, bool show = false, const std::string &option = "" )
		{ addOrBind(name, param, Param::PARAM_VEC3F, category, show, option); };

		void addParam( const std::string &name, ci::Color *param, const std::string &category, bool show = false, const std::string &option = "" )
		{ addOrBind(name, param, Param::PARAM_COLOR, category, show, option); };

		void addParam( const std::string &name, ci::ColorA *param, const std::string &category, bool show = false, const std::string &option = "" )
		{ addOrBind(name, param, Param::PARAM_COLORA, category, show, option); };

		void addParam( const std::string &name, std::string *param, const std::string &category, bool show = false, const std::string &option = "" )
		{ addOrBind(name, param, Param::PARAM_STRING, category, show, option); };

	private:
		
		template<typename T>
		void addOrBind( const std::string &name, T *param, Param::ParamType paramType, const std::string &category, bool show, const std::string &option )
		{
			std::string catg = category;

			if ( catg == "" ) 
			{
				catg = "_";
			}

			Param *p = getParam(name);

			if ( p )
			{
				p->mParam = param;
				p->mShow = show;
				p->mOption = option;
				p->mCategory = catg;
			}
			else
			{
				mParams.push_back( new Param( name, param, paramType, catg, show, option ) );
			}

			mParamsChanged = true;
		}
		
		std::string					mFilename;
		std::vector<Param*>			mParams;
		ci::XmlTree					mXmlAsset;
		ci::params::InterfaceGl		mParamGUI;
		bool						mParamsChanged;
	};

} } // namespace cinder::settings